#QUESTIONS:
#pulse duration?
#documentation of the device (c-mark, etc...) for ethics

# Somatosensory oddball (left/right) – PARALLEL PORT VERSION
# One run per execution
# Parallel port triggers

import random
import os
import pandas as pd

from psychopy import core
from psychopy import parallel

#  PARALLEL PORT ADDRESS
EEG_PORT_ADDRESS = 0x0378

# Create parallel port object
port_eeg = parallel.ParallelPort(address=EEG_PORT_ADDRESS)

#  Directories and run/subject handling
BASE_DIR = "stimulation_code"
RUNS_DIR = os.path.join(BASE_DIR, "runs")
os.makedirs(RUNS_DIR, exist_ok=True)

def get_next_subject_and_run(runs_dir: str):
    """
    Find existing run files in runs_dir with pattern:
      sub-XXX_task_run-YY.csv
    and decide:
      - next subject ID (XXX)
      - next run number (YY) for that subject

    Rules:
      - If no files: sub-001, run 1
      - Else: find max subject ID, check its runs:
            * if that subject has < 8 runs → same subject, run+1
            * if that subject already has 8 runs → next subject, run 1
    """
    files = os.listdir(runs_dir)
    run_files = [
        f for f in files
        if f.startswith("sub-") and "_task_run-" in f and f.endswith(".csv")
    ]

    if not run_files:
        return "001", 1

    subject_runs = {}  # subj_int -> list of run_int
    for fname in run_files:
        try:
            after_sub = fname.replace("sub-", "")
            subj_str, rest = after_sub.split("_task_run-")
            run_str = rest.replace(".csv", "")
            subj = int(subj_str)
            run = int(run_str)
        except Exception:
            # Ignore files that do not match the pattern
            continue

        subject_runs.setdefault(subj, []).append(run)

    if not subject_runs:
        return "001", 1

    max_subj = max(subject_runs.keys())
    max_run_for_max_subj = max(subject_runs[max_subj])

    if max_run_for_max_subj >= 8:
        # Last subject already has 8 runs → new subject
        next_subj = max_subj + 1
        next_run = 1
    else:
        # Continue with same subject, next run
        next_subj = max_subj
        next_run = max_run_for_max_subj + 1

    return f"{next_subj:03d}", next_run


def get_run_filename(subject_id: str, run_number: int) -> str:
    """
    Build filename: sub-XXX_task_run-YY.csv
    """
    return f"sub-{subject_id}_task_run-{run_number:02d}.csv"


# Get subject ID and run number for THIS execution
PARTICIPANT_ID, RUN_NUMBER = get_next_subject_and_run(RUNS_DIR)
SESSION = 1  # fixed for now


#  Experiment parameters (ONE RUN per execution)
TRIALS_PER_RUN = 500      # number of trials in this run
MIN_RUN = 3               # minimum same-side run length
MAX_RUN = 7               # maximum same-side run length (max beat within run)
ISI_FIXED = 0.700         # ISI in seconds (700 ms)


#  Helper functions
def generate_isis_fixed(n_trials: int, isi_s: float):
    """
    Generate a list of constant ISIs (no jitter).
    """
    return [isi_s for _ in range(n_trials)]


def generate_sides_for_run(trials_per_run: int, min_run: int, max_run: int):
    """
    Generate a left/right sequence in runs of [min_run, max_run],
    alternating side between runs.
    """
    sides = []
    current_side = random.choice(["right", "left"])
    while len(sides) < trials_per_run:
        run_length = random.randint(min_run, max_run)
        for _ in range(run_length):
            if len(sides) >= trials_per_run:
                break
            sides.append(current_side)
        # Switch side for the next run
        current_side = "left" if current_side == "right" else "right"
    return sides


def encode_trigger(beat: int, side: str, kind: str) -> int:
    """
    Encode trigger as a 6-bit integer: [R][L][D][c2][c1][c0]

      bit 5 (R): 1 if RIGHT side, 0 otherwise
      bit 4 (L): 1 if LEFT  side, 0 otherwise
                 (R and L are never 1 at the same time)

      bit 3 (D): 1 if DEVIANT, 0 if STANDARD

      bits 2–0 (c2,c1,c0): beat counter within same-side run (1–7)

    Examples:
      side='right', kind='standard', beat=3
         → R=1,L=0,D=0,count=3 (011) → 100011 (bin) = 35 (dec)

      side='left',  kind='deviant', beat=5
         → R=0,L=1,D=1,count=5 (101) → 011101 (bin) = 29 (dec)
    """
    if not (1 <= beat <= 7):
        raise ValueError("beat should be between 1 and 7 to fit in 3 bits")

    # Side bits
    if side == "right":
        side_bits = 0b100000   # R=1, L=0
    elif side == "left":
        side_bits = 0b010000   # R=0, L=1
    else:
        raise ValueError("side should be 'right' or 'left'")

    # Kind bit
    if kind == "standard":
        kind_bit = 0b000000    # D=0
    elif kind == "deviant":
        kind_bit = 0b001000    # D=1
    else:
        raise ValueError("kind should be 'standard' or 'deviant'")

    # Counter bits (3 bits) – here we use beat directly (1–7)
    counter_bits = (beat & 0b111)

    trigger = side_bits | kind_bit | counter_bits
    return trigger

def process_run(sides):
    """
    From a sequence of sides (left/right), compute for each trial:
      - beat: position within the same-side run (1, 2, 3, ...)
      - kind: 'standard' or 'deviant'
      - trigger: encoded 6-bit trigger code [R][L][D][c2][c1][c0]
    """
    beats = []
    kinds = []
    triggers = []

    previous_side = None
    current_beat = 0

    for trial_index, current_side in enumerate(sides):
        # Beat within same-side run
        if previous_side is None or current_side != previous_side:
            current_beat = 1
        else:
            current_beat += 1

        # Seguridad: asumimos MAX_RUN <= 7
        if current_beat > 7:
            raise ValueError("Current beat exceeded 7; increase coding bits or reduce MAX_RUN")

        beats.append(current_beat)

        # Standard vs deviant
        if trial_index == 0:
            kind = "standard"
        else:
            kind = "standard" if current_side == previous_side else "deviant"
        kinds.append(kind)

        # Trigger value
        trigger_value = encode_trigger(current_beat, current_side, kind)
        triggers.append(trigger_value)

        previous_side = current_side

    return beats, kinds, triggers

#  Trigger sending
PULSE_DURATION_S = 0.005  # duration of the pulse on the port (seconds)

def send_trigger(trigger_code: int) -> None:
    """
    Sends the 6-bit trigger code directly to the parallel port.

    Bits (from MSB to LSB): [R][L][D][c2][c1][c0]

      R (bit 5) = 1 if RIGHT, 0 otherwise
      L (bit 4) = 1 if LEFT,  0 otherwise
      D (bit 3) = 1 if DEVIANT, 0 if STANDARD
      c2..c0    = beat counter within run (1–7)
    """
    port_eeg.setData(trigger_code)
    core.wait(PULSE_DURATION_S)
    port_eeg.setData(0)

#  Build SINGLE RUN structure
all_trials = []

sides = generate_sides_for_run(TRIALS_PER_RUN, MIN_RUN, MAX_RUN)
isis = generate_isis_fixed(TRIALS_PER_RUN, ISI_FIXED)
beats, kinds, triggers = process_run(sides)

for trial_index in range(TRIALS_PER_RUN):
    isi_s = isis[trial_index]
    isi_ms = int(round(isi_s * 1000))

    row = {
        "participant_id": PARTICIPANT_ID,
        "session": SESSION,
        "run": RUN_NUMBER,
        "trial_in_run": trial_index + 1,
        "side": sides[trial_index],
        "beat": beats[trial_index],
        "kind": kinds[trial_index],
        "trigger": triggers[trial_index],
        "trigger_bin": "'" + format(triggers[trial_index], "06b"),
        "ISI_ms": isi_ms,
        "onset_ms": None,
    }
    all_trials.append(row)

# Compute ideal onset times in seconds from ISIs (absolute timing)
scheduled_onsets_s = []
t = 0.0
for trial in all_trials:
    isi_s = trial["ISI_ms"] / 1000.0
    t += isi_s
    scheduled_onsets_s.append(t)

#  Presentation loop with absolute timing
print("PARALLEL PORT MODE: somatosensory oddball (left/right).")
print(f"Subject (participant_id): {PARTICIPANT_ID}")
print(f"Run number: {RUN_NUMBER:02d}")
print(f"Trials in this run: {TRIALS_PER_RUN}")
print("Running one run now (no window, only timing and triggers)...\n")

exp_clock = core.Clock()
exp_clock.reset()

for i, trial in enumerate(all_trials):
    # Ideal onset time (in seconds from start of run)
    target_onset_s = scheduled_onsets_s[i]

    # Coarse waiting: sleep in 1 ms chunks until close to target
    while True:
        now_s = exp_clock.getTime()
        remaining_s = target_onset_s - now_s
        if remaining_s <= 0:
            break
        if remaining_s > 0.005:
            core.wait(0.001)  # sleep ~1 ms
        else:
            # Last <= 5 ms: busy-wait loop for maximum precision
            pass

    # Actual onset time just before sending trigger
    onset_s = exp_clock.getTime()
    onset_ms = int(round(onset_s * 1000))
    trial["onset_ms"] = onset_ms

    trigger_code = trial["trigger"]
    send_trigger(trigger_code)

    print(
        f"Trial {i+1:4d}/{TRIALS_PER_RUN} | "
        f"side={trial['side']:5s} | "
        f"kind={trial['kind']:8s} | "
        f"beat={trial['beat']:2d} | "
        f"trigger={trigger_code:2d} | "
        f"ISI={trial['ISI_ms']:3d} ms | "
        f"onset={onset_ms} ms",
        flush=True
    )

print(f"\nRun {RUN_NUMBER:02d} for subject {PARTICIPANT_ID} finished.")

#  Save CSV for THIS RUN
df = pd.DataFrame(all_trials)
filename = get_run_filename(PARTICIPANT_ID, RUN_NUMBER)
filepath = os.path.join(RUNS_DIR, filename)
df.to_csv(filepath, index=False)

print(f"CSV saved as: {filepath}")
print(f"✓ Run {RUN_NUMBER:02d} for subject {PARTICIPANT_ID} FINISHED COMPLETELY.")
print("======================================================")

