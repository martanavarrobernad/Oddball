# Somatosensory oddball (left/right) – HEADLESS TEST MODE
# - No PsychoPy window
# - No keyboard
# - One run per execution
# - NO parallel port (no real triggers)
# - Automatic naming:
#       sub-001_task_run-01.csv
#       sub-001_task_run-02.csv
#       ...
#       sub-001_task_run-08.csv
#       sub-002_task_run-01.csv
#       etc.
# - Prints info for EVERY stimulus (trial)

import random
import os
import pandas as pd
from psychopy import core  # only timing, no visual, no event

# =======================================
# Dummy trigger (no real triggers)
# =======================================
def send_trigger(code: int) -> None:
    """
    TEST MODE: no real trigger is sent.
    """
    # If you want to simulate trigger latency, you could add a tiny wait here.
    # core.wait(0.001)
    pass


# =======================================
# Directories and run/subject handling
# =======================================
BASE_DIR = "stimulation_code"
RUNS_DIR = os.path.join(BASE_DIR, "runs")
os.makedirs(RUNS_DIR, exist_ok=True)


def get_next_subject_and_run(runs_dir: str):
    """
    Look into runs_dir for files named:
      sub-XXX_task_run-YY.csv

    Decide:
      - next subject ID (XXX)
      - next run number (YY) for that subject

    Rules:
      - If no files: sub-001, run 1
      - Else: find max subject; if that subject has < 8 runs → same subject, run+1
              if that subject already has 8 runs → next subject, run 1
    """
    files = os.listdir(runs_dir)
    run_files = [f for f in files
                 if f.startswith("sub-") and "_task_run-" in f and f.endswith(".csv")]

    if not run_files:
        return "001", 1

    subject_runs = {}  # subj_int -> list of run_int
    for fname in run_files:
        # Pattern: sub-XXX_task_run-YY.csv
        try:
            after_sub = fname.replace("sub-", "")
            subj_str, rest = after_sub.split("_task_run-")
            run_str = rest.replace(".csv", "")
            subj = int(subj_str)
            run = int(run_str)
        except Exception:
            # Ignore any file that doesn't match the pattern
            continue

        subject_runs.setdefault(subj, []).append(run)

    if not subject_runs:
        return "001", 1

    max_subj = max(subject_runs.keys())
    max_run_for_max_subj = max(subject_runs[max_subj])

    # 8 runs per subject
    if max_run_for_max_subj >= 8:
        # Last subject already has 8 runs → new subject
        next_subj = max_subj + 1
        next_run = 1
    else:
        # Continue with same subject, next run
        next_subj = max_subj
        next_run = max_run_for_max_subj + 1

    return f"{next_subj:03d}", next_run


def get_run_filename(subject_id: str, run_number: int) -> str:
    """
    Build filename: sub-XXX_task_run-YY.csv
    """
    return f"sub-{subject_id}_task_run-{run_number:02d}.csv"


# Get subject ID and run number for THIS execution
PARTICIPANT_ID, RUN_NUMBER = get_next_subject_and_run(RUNS_DIR)
SESSION = 1  # fixed for now


# =======================================
# Experiment parameters (ONE RUN per execution)
# =======================================

TRIALS_PER_RUN = 500      # 500 trials per run in the real experiment

# Longitudes de rachas (runs) mismo lado
MIN_RUN = 3               # min same-side run length
MAX_RUN = 7               # max same-side run length

# ISI fijo de 700 ms, sin jitter
ISI_FIXED = 0.700         # seconds (700 ms)


# =======================================
# Helper functions
# =======================================
def generate_isis_fixed(n_trials: int, isi_s: float):
    """
    Genera una lista de ISIs constantes (sin jitter).
    """
    return [isi_s for _ in range(n_trials)]


def generate_sides_for_run(trials_per_run: int, min_run: int, max_run: int):
    """
    Generate left/right sequence in runs of [min_run, max_run],
    alternating side between runs.
    """
    sides = []
    current_side = random.choice(["right", "left"])
    while len(sides) < trials_per_run:
        run_length = random.randint(min_run, max_run)
        for _ in range(run_length):
            if len(sides) >= trials_per_run:
                break
            sides.append(current_side)
        current_side = "left" if current_side == "right" else "right"
    return sides


def encode_trigger(beat: int, side: str, kind: str) -> int:
    """
    Encoding (5 bits total):

    bit 0:   side      (0 = right, 1 = left)
    bits 1–3: beat-1   (0–7 → beats 1–8)
    bit 4:   kind      (0 = standard, 1 = deviant)
    """
    if not (1 <= beat <= 8):
        raise ValueError("beat should be between 1 and 8")

    if side == "right":
        side_bit = 0
    elif side == "left":
        side_bit = 1
    else:
        raise ValueError("side should be 'right' or 'left'")

    if kind == "standard":
        kind_bit = 0
    elif kind == "deviant":
        kind_bit = 1
    else:
        raise ValueError("kind should be 'standard' or 'deviant'")
    kind_bit = kind_bit << 4          # move to bit 4

    beat_bits = (beat - 1) << 1       # bits 1–3

    trigger = kind_bit | beat_bits | side_bit
    return trigger


def process_run(sides):
    """
    From a sequence of sides (left/right), compute:
      - beat (position in same-side run)
      - kind (standard / deviant)
      - trigger code
    """
    beats = []
    kinds = []
    triggers = []

    previous_side = None
    current_beat = 0

    for trial_index, current_side in enumerate(sides):
        # beat within run
        if previous_side is None or current_side != previous_side:
            current_beat = 1
        else:
            current_beat += 1
        beats.append(current_beat)

        # standard / deviant
        if trial_index == 0:
            kind = "standard"
        else:
            kind = "standard" if current_side == previous_side else "deviant"
        kinds.append(kind)

        # trigger value
        trigger_value = encode_trigger(current_beat, current_side, kind)
        triggers.append(trigger_value)

        previous_side = current_side

    return beats, kinds, triggers


# =======================================
# Build SINGLE RUN structure for this execution
# =======================================
all_trials = []

sides = generate_sides_for_run(TRIALS_PER_RUN, MIN_RUN, MAX_RUN)
isis = generate_isis_fixed(TRIALS_PER_RUN, ISI_FIXED)
beats, kinds, triggers = process_run(sides)

for trial_index in range(TRIALS_PER_RUN):
    isi_s = isis[trial_index]
    isi_ms = int(round(isi_s * 1000))

    row = {
        "participant_id": PARTICIPANT_ID,
        "session": SESSION,
        "run": RUN_NUMBER,  # run number for this subject
        "trial_in_run": trial_index + 1,
        "side": sides[trial_index],
        "beat": beats[trial_index],
        "kind": kinds[trial_index],
        "trigger": triggers[trial_index],
        "trigger_bin": "'" + format(triggers[trial_index], "05b"),
        "ISI_ms": isi_ms,
        "onset_ms": None,
    }
    all_trials.append(row)

# Calcular onsets ideales (en segundos) a partir de los ISIs
scheduled_onsets_s = []
t = 0.0
for trial in all_trials:
    isi_s = trial["ISI_ms"] / 1000.0
    t += isi_s
    scheduled_onsets_s.append(t)


# =======================================
# Presentation loop for THIS RUN (headless)
# with absolute timing (better ISI precision)
# =======================================
print("HEADLESS TEST MODE: somatosensory oddball (left/right), no real triggers.")
print(f"Subject (participant_id): {PARTICIPANT_ID}")
print(f"Run number: {RUN_NUMBER:02d}")
print(f"Trials in this run: {TRIALS_PER_RUN}")
print("Running one run now (no window, no keyboard)...\n")

exp_clock = core.Clock()
exp_clock.reset()

for i, trial in enumerate(all_trials):
    # Ideal onset time (in seconds from start of run)
    target_onset_s = scheduled_onsets_s[i]

    # Coarse wait: while more than 5 ms remain, sleep in 1 ms chunks
    while True:
        now_s = exp_clock.getTime()
        remaining_s = target_onset_s - now_s
        if remaining_s <= 0:
            break
        if remaining_s > 0.005:
            core.wait(0.001)  # sleep ~1 ms
        else:
            # Last <= 5 ms: tight loop to refine timing
            pass

    # Actual onset time just before sending trigger
    onset_s = exp_clock.getTime()
    onset_ms = int(round(onset_s * 1000))

    trigger_code = trial["trigger"]
    send_trigger(trigger_code)
    trial["onset_ms"] = onset_ms

    print(
        f"Trial {i+1:4d}/{TRIALS_PER_RUN} | "
        f"side={trial['side']:5s} | "
        f"kind={trial['kind']:8s} | "
        f"beat={trial['beat']:2d} | "
        f"trigger={trigger_code:2d} | "
        f"ISI={trial['ISI_ms']:3d} ms | "
        f"onset={onset_ms} ms",
        flush=True
    )

print(f"\nRun {RUN_NUMBER:02d} for subject {PARTICIPANT_ID} finished.")


# =======================================
# Save CSV for THIS RUN
# =======================================
df = pd.DataFrame(all_trials)
filename = get_run_filename(PARTICIPANT_ID, RUN_NUMBER)
filepath = os.path.join(RUNS_DIR, filename)
df.to_csv(filepath, index=False)

print("CSV saved as:", filepath)
print("HEADLESS TEST MODE finished (no real triggers were sent).")

